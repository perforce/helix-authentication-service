//
// Copyright 2023 Perforce Software
//
import * as assert from 'node:assert'

/**
 * Convert the providers in AUTH_PROVIDERS into classic settings, if one OIDC
 * and SAML provider are defined, otherwise remove any classic OIDC/SAML
 * settings to avoid duplication and confusion.
 *
 * @param {Map} settings - Map-like object containing all settings.
 */
export default ({ tidyAuthProviders, validateAuthProvider }) => {
  assert.ok(tidyAuthProviders, 'tidyAuthProviders must be defined')
  assert.ok(validateAuthProvider, 'validateAuthProvider must be defined')
  return async (settings) => {
    assert.ok(settings, 'settings must be provided')
    if (settings.has('AUTH_PROVIDERS')) {
      let providers = settings.get('AUTH_PROVIDERS')
      await tidyAuthProviders(providers)
      // retain only the valid providers, especially useful to remove the
      // incomplete providers generated by the default settings
      providers = providers.filter((e) => validateAuthProvider(e) === null)
      const incomingCount = providers.length
      const oidcProviders = providers.filter((e) => e.protocol === 'oidc')
      if (oidcProviders.length === 1) {
        // convert the one OIDC provider to standard settings
        convert(settings, oidcProviders[0], oidcNameMapping)
        providers = providers.filter((e) => e.id !== oidcProviders[0].id)
      }
      const samlProviders = providers.filter((e) => e.protocol === 'saml')
      if (samlProviders.length === 1) {
        // convert the one SAML provider to standard settings
        convert(settings, samlProviders[0], samlNameMapping)
        providers = providers.filter((e) => e.id !== samlProviders[0].id)
      }
      if (providers.length === 0) {
        // either no incoming providers or all were converted
        settings.delete('AUTH_PROVIDERS')
      } else if (incomingCount > providers.length) {
        // some providers were converted and the list was altered
        settings.set('AUTH_PROVIDERS', providers)
      }
      if (oidcProviders.length === 0 || oidcProviders.length > 1) {
        // remove classic OIDC settings if nothing was converted
        for (const env of Object.keys(oidcNameMapping)) {
          settings.delete(env)
        }
      }
      if (samlProviders.length === 0 || samlProviders.length > 1) {
        // remove classic SAML settings if nothing was converted
        for (const env of Object.keys(samlNameMapping)) {
          settings.delete(env)
        }
      }
    }
  }
}

// Mapping of OIDC settings from environment variable names to provider properties.
const oidcNameMapping = {
  'OIDC_CLIENT_ID': 'clientId',
  'OIDC_CLIENT_SECRET': 'clientSecret',
  'OIDC_CODE_CHALLENGE_METHOD': 'codeChallenge',
  'OIDC_INFO_LABEL': 'label',
  'OIDC_ISSUER_URI': 'issuerUri',
  'OIDC_SELECT_ACCOUNT': 'selectAccount',
  'OIDC_TOKEN_SIGNING_ALGO': 'signingAlgo'
}

// Mapping of SAML settings from environment variable names to provider properties.
const samlNameMapping = {
  'IDP_CERT': 'idpCert',
  'SAML_AUTHN_CONTEXT': 'authnContext',
  'SAML_DISABLE_CONTEXT': 'disableContext',
  'SAML_IDP_ENTITY_ID': 'idpEntityId',
  'SAML_IDP_METADATA': 'metadata',
  'SAML_IDP_METADATA_URL': 'metadataUrl',
  'SAML_IDP_SLO_URL': 'logoutUrl',
  'SAML_IDP_SSO_URL': 'signonUrl',
  'SAML_INFO_LABEL': 'label',
  'SAML_NAMEID_FORMAT': 'nameIdFormat',
  'SAML_SP_AUDIENCE': 'audience',
  'SAML_SP_ENTITY_ID': 'spEntityId',
  'SAML_WANT_ASSERTION_SIGNED': 'wantAssertionSigned',
  'SAML_WANT_RESPONSE_SIGNED': 'wantResponseSigned',
  'SP_KEY_ALGO': 'keyAlgorithm'
}

function convert(settings, provider, mapping) {
  for (const [env, prov] of Object.entries(mapping)) {
    if (prov in provider && provider[prov] !== '') {
      settings.set(env, provider[prov])
    } else {
      settings.delete(env)
    }
  }
}
